buildscript {
  repositories {
    mavenCentral()
  }

  dependencies {
    classpath 'com.google.guava:guava:23.0'
  }
}

import static com.google.common.base.CaseFormat.LOWER_HYPHEN;
import static com.google.common.base.CaseFormat.UPPER_CAMEL;

ext.goWorkspace = new File(project.projectDir, '../../../..').canonicalPath
ext.goBinariesDir = new File(goWorkspace, 'bin')
ext.goSourceDir = new File(goWorkspace, 'src')
ext.binariesDir = new File(projectDir, 'binaries')

ext.relativeBinariesdDir = binariesDir.canonicalPath.substring(goSourceDir.canonicalPath.length() + 1)
ext.relativeBuildDir = buildDir.canonicalPath.substring(goSourceDir.canonicalPath.length() + 1)
ext.relativeSourceDir = projectDir.canonicalPath.substring(goSourceDir.canonicalPath.length() + 1)

ext.packages = 'go list ./...'
  .execute()
  .text
  .split("\n")
  .sort()
  .findAll{ !it.startsWith(relativeBuildDir) }
  .findAll{ !it.startsWith(relativeBinariesdDir) }

ext.sourceFiles = fileTree(dir: '.', include: '**/*.go') - fileTree(dir: buildDir)

ext.binaries = binariesDir.listFiles()
  .findAll{ it.isDirectory() }
  .collect{ it.name }

ext.binaryFiles = binaries.collect{ file("${goBinariesDir}/${it}") }

logger.info '-----------------'
logger.info "Go workspace: ${goWorkspace}"
logger.info "Binaries output: ${goBinariesDir}"
logger.info "Packages: ${packages}"
logger.info "Relative source dir: ${relativeSourceDir}"
logger.info "Relative build dir: ${relativeBuildDir}"
logger.info "Relative binaries dir: ${relativeBinariesdDir}"
logger.info "Binary names: ${binaries}"
logger.info "Binary files that will be generated: ${binaryFiles}"
logger.info "All source files: ${sourceFiles.collect{ it.canonicalPath }}"
logger.info '-----------------'

task lint(type:Exec) {
  inputs.files sourceFiles
  outputs.files sourceFiles

  commandLine('golint', '-set_exit_status', *packages)
}

task install {}

binaries.each { binaryName ->
  def binaryNameCamelCase = LOWER_HYPHEN.to(UPPER_CAMEL, binaryName)
  def taskName = "install${binaryNameCamelCase}"

  task "${taskName}" (type:Exec) {
    inputs.files sourceFiles
    outputs.file goBinariesDir

    workingDir "${binariesDir}/${binaryName}"
    commandLine 'go', 'install'
  }

  install.dependsOn taskName
}

task fmtCompare {
  def fmtOutput = "${buildDir}/fmtOut"

  inputs.files sourceFiles
  outputs.files fileTree(dir: fmtOutput, include: '/**/*.go')

  doLast {
    sourceFiles.each {
      def parentPath = it.parentFile.canonicalPath
      def relativePath = parentPath.substring(goSourceDir.canonicalPath.length())

      mkdir "${fmtOutput}/${relativePath}"

      def outputFile = new File("${fmtOutput}/${relativePath}", it.name)
      outputFile.createNewFile()
      outputFile.text = "gofmt -s ${it}".execute().text

      def diff = "diff ${it} ${outputFile}".execute().text
      if (diff != '') {
        throw new GradleException("gofmt -s found some differences:\n${diff}")
      }
    }
  }
}

task test {
  def coverageOuptut = "${buildDir}/coverage"

  inputs.files sourceFiles
  outputs.files fileTree(dir: coverageOuptut)

  doFirst {
    packages.each {
      mkdir "${coverageOuptut}/${it}"
    }
  }

  doLast {
    packages.reverse().each{
      def outputFile = "${coverageOuptut}/${it}/package.cover"

      def sout = new StringBuilder()
      def serr = new StringBuilder()

      def proc = "go test --coverprofile=${outputFile} ${it}".execute(["GOPATH=${goWorkspace}"], projectDir)
      proc.consumeProcessOutput(sout, serr)
      proc.waitForOrKill(10000)

      if (proc.exitValue() != 0) {
        throw new GradleException("Error while executing tests:\nStdOut:\n${sout}\nStdErr:\n${serr}")
      }
    }
  }
}

task aggregateCoverateReports() {
  ext.aggregatedCovarage = file("${buildDir}/all.cover")

  dependsOn test
  outputs.file aggregatedCovarage

  doLast {
    def aggregatedData = "mode: set\n"

    test.outputs.files.each {
      def content = it.text
      def firstLineIndex = content.indexOf("\n")
      aggregatedData += content.substring(firstLineIndex + 1).trim()
      aggregatedData += "\n"
    }

    aggregatedCovarage.createNewFile()
    aggregatedCovarage.text = aggregatedData
  }
}

task generateCoverageReport(type: Exec) {
  def coverageFile = file("${buildDir}/reportCoverage.html")

  dependsOn aggregateCoverateReports
  outputs.file coverageFile

  commandLine 'go', 'tool', 'cover', "-html=${aggregateCoverateReports.aggregatedCovarage}", '-o', coverageFile
}

task clean(type: Delete) {
  description "Delete the build folder and the generated binary"
  delete buildDir, binaryFiles
}

task build {
  dependsOn fmtCompare, lint, test, install, generateCoverageReport
}
