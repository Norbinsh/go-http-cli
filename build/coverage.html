
<!DOCTYPE html>
<html>
	<head>
		<meta http-equiv="Content-Type" content="text/html; charset=utf-8">
		<style>
			body {
				background: black;
				color: rgb(80, 80, 80);
			}
			body, pre, #legend span {
				font-family: Menlo, monospace;
				font-weight: bold;
			}
			#topbar {
				background: black;
				position: fixed;
				top: 0; left: 0; right: 0;
				height: 42px;
				border-bottom: 1px solid rgb(80, 80, 80);
			}
			#content {
				margin-top: 50px;
			}
			#nav, #legend {
				float: left;
				margin-left: 10px;
			}
			#legend {
				margin-top: 12px;
			}
			#nav {
				margin-top: 10px;
			}
			#legend span {
				margin: 0 5px;
			}
			.cov0 { color: rgb(192, 0, 0) }
.cov1 { color: rgb(128, 128, 128) }
.cov2 { color: rgb(116, 140, 131) }
.cov3 { color: rgb(104, 152, 134) }
.cov4 { color: rgb(92, 164, 137) }
.cov5 { color: rgb(80, 176, 140) }
.cov6 { color: rgb(68, 188, 143) }
.cov7 { color: rgb(56, 200, 146) }
.cov8 { color: rgb(44, 212, 149) }
.cov9 { color: rgb(32, 224, 152) }
.cov10 { color: rgb(20, 236, 155) }

		</style>
	</head>
	<body>
		<div id="topbar">
			<div id="nav">
				<select id="files">
				
				<option value="file0">github.com/visola/go-http-cli/config/command_line_configuration.go (95.3%)</option>
				
				<option value="file1">github.com/visola/go-http-cli/config/configuration.go (86.7%)</option>
				
				<option value="file2">github.com/visola/go-http-cli/config/hierarchical_configuration.go (100.0%)</option>
				
				<option value="file3">github.com/visola/go-http-cli/config/yaml_configuration.go (86.7%)</option>
				
				</select>
			</div>
			<div id="legend">
				<span>not tracked</span>
			
				<span class="cov0">not covered</span>
				<span class="cov8">covered</span>
			
			</div>
		</div>
		<div id="content">
		
		<pre class="file" id="file0" style="display: none">package config

import (
        "errors"
        "os"
        "strings"

        flag "github.com/spf13/pflag"
)

type arrayFlags []string

func (i *arrayFlags) String() string <span class="cov8" title="1">{
        return "No String Representation"
}</span>

func (i *arrayFlags) Set(value string) error <span class="cov8" title="1">{
        *i = append(*i, value)
        return nil
}</span>

func (i *arrayFlags) Type() string <span class="cov0" title="0">{
        return "headers"
}</span>

type commandLineConfiguration struct {
        ConfigurationPaths []string
        headers            map[string][]string
        body               string
        method             string
        url                string
}

func (conf commandLineConfiguration) Headers() map[string][]string <span class="cov8" title="1">{
        return conf.headers
}</span>

func (conf commandLineConfiguration) Body() string <span class="cov8" title="1">{
        return conf.body
}</span>

func (conf commandLineConfiguration) Method() string <span class="cov8" title="1">{
        return conf.method
}</span>

func (conf commandLineConfiguration) URL() string <span class="cov8" title="1">{
        return conf.url
}</span>

func parseHeaders(headers arrayFlags) (map[string][]string, error) <span class="cov8" title="1">{
        result := make(map[string][]string)

        for _, kv := range headers </span><span class="cov8" title="1">{
                s := strings.Split(kv, "=")
                if len(s) != 2 </span><span class="cov8" title="1">{
                        return result, errors.New("Error while parsing header '" + kv + "'\nShould be a '=' separated key/value, e.g.: Content-type=application/x-www-form-urlencoded")
                }</span>

                <span class="cov8" title="1">key := s[0]
                value := s[1]

                if existingValue, ok := result[key]; ok </span><span class="cov8" title="1">{
                        result[key] = append(existingValue, value)
                }</span><span class="cov8" title="1"> else {
                        result[key] = []string{value}
                }</span>
        }

        <span class="cov8" title="1">return result, nil</span>
}

func parseURL(args []string) (string, error) <span class="cov8" title="1">{
        return args[0], nil
}</span>

func parseCommandLine(args []string) (*commandLineConfiguration, error) <span class="cov8" title="1">{
        var method string
        var body string
        var headers arrayFlags
        var configPaths arrayFlags

        commandLine := flag.NewFlagSet(os.Args[0], flag.ExitOnError)

        commandLine.StringVarP(&amp;method, "method", "X", "GET", "HTTP method to be used")
        commandLine.StringVarP(&amp;body, "data", "d", "", "Data to be sent as body")
        commandLine.VarP(&amp;headers, "header", "H", "Headers to include with your request")
        commandLine.VarP(&amp;configPaths, "config", "c", "Path to configuration files to be used")

        commandLine.Parse(args)

        result := new(commandLineConfiguration)
        result.method = method
        result.body = body

        result.ConfigurationPaths = configPaths

        url, urlError := parseURL(commandLine.Args())
        result.url = url

        if urlError != nil </span><span class="cov0" title="0">{
                return result, urlError
        }</span>

        <span class="cov8" title="1">parsedHeaders, headerError := parseHeaders(headers)
        result.headers = parsedHeaders

        if headerError != nil </span><span class="cov8" title="1">{
                return result, headerError
        }</span>

        <span class="cov8" title="1">return result, nil</span>
}
</pre>
		
		<pre class="file" id="file1" style="display: none">// Package config has all the things required to parse configuration from command line arguments
// and files.
package config

import (
        "errors"
        "os"
)

// Configuration stores all the configuration that will be used to build the request.
type Configuration interface {
        Headers() map[string][]string
        Body() string
        Method() string
        URL() string
}

// Parse parses arguments and create a Configuration object.
func Parse(args []string) (Configuration, error) <span class="cov8" title="1">{
        commandLineConfiguration, err := parseCommandLine(args)
        if err != nil </span><span class="cov8" title="1">{
                return nil, err
        }</span>

        // We'll have at least one configuration
        <span class="cov8" title="1">configurations := []Configuration{}

        if len(commandLineConfiguration.ConfigurationPaths) &gt; 0 </span><span class="cov8" title="1">{
                for _, configPath := range commandLineConfiguration.ConfigurationPaths </span><span class="cov8" title="1">{
                        if _, err := os.Stat(configPath); os.IsNotExist(err) </span><span class="cov0" title="0">{
                                return commandLineConfiguration, errors.New("Configuration file does not exist: " + configPath)
                        }</span>
                        <span class="cov8" title="1">yamlConfig, err := readFrom(configPath)
                        if err != nil </span><span class="cov0" title="0">{
                                return commandLineConfiguration, err
                        }</span>
                        <span class="cov8" title="1">configurations = append(configurations, yamlConfig)</span>
                }
        }

        <span class="cov8" title="1">configurations = append(configurations, commandLineConfiguration)

        result := hierarchicalConfigurationFormat{
                configurations: configurations,
        }
        return result, nil</span>
}
</pre>
		
		<pre class="file" id="file2" style="display: none">package config

type hierarchicalConfigurationFormat struct {
        configurations []Configuration
}

func (conf hierarchicalConfigurationFormat) Headers() map[string][]string <span class="cov8" title="1">{
        result := make(map[string][]string)
  for _, subConfig := range conf.configurations </span><span class="cov8" title="1">{
    for k, v := range subConfig.Headers() </span><span class="cov8" title="1">{
      result[k] = v
    }</span>
  }
  <span class="cov8" title="1">return result</span>
}

func (conf hierarchicalConfigurationFormat) Body() string <span class="cov8" title="1">{
  var result string
  for _, subConfig := range conf.configurations </span><span class="cov8" title="1">{
    if subConfig.Body() != "" </span><span class="cov8" title="1">{
      result = subConfig.Body()
    }</span>
  }
        <span class="cov8" title="1">return result</span>
}

func (conf hierarchicalConfigurationFormat) Method() string <span class="cov8" title="1">{
  var result string
  for _, subConfig := range conf.configurations </span><span class="cov8" title="1">{
    if subConfig.Method() != "" </span><span class="cov8" title="1">{
      result = subConfig.Method()
    }</span>
  }
        <span class="cov8" title="1">return result</span>
}

func (conf hierarchicalConfigurationFormat) URL() string <span class="cov8" title="1">{
  var result string
  for _, subConfig := range conf.configurations </span><span class="cov8" title="1">{
    if subConfig.URL() != "" </span><span class="cov8" title="1">{
      result = subConfig.URL()
    }</span>
  }
        <span class="cov8" title="1">return result</span>
}
</pre>
		
		<pre class="file" id="file3" style="display: none">package config

import (
        "io/ioutil"

        "gopkg.in/yaml.v2"
)

// Used to unmarshal data from YAML files
type yamlConfigurationFormat struct {
        Headers map[string][]string
}

// Configuration implementation that wraps configuration coming from a YAML file
type fileConfiguration struct {
        parsedYaml *yamlConfigurationFormat
}

func (conf fileConfiguration) Headers() map[string][]string <span class="cov8" title="1">{
        return conf.parsedYaml.Headers
}</span>

func (conf fileConfiguration) Body() string <span class="cov8" title="1">{
        return ""
}</span>

func (conf fileConfiguration) Method() string <span class="cov8" title="1">{
        return ""
}</span>

func (conf fileConfiguration) URL() string <span class="cov8" title="1">{
        return ""
}</span>

func readFrom(pathToYamlFile string) (*fileConfiguration, error) <span class="cov8" title="1">{
        yamlConfiguration := new(yamlConfigurationFormat)

        var err error
        var yamlContent []byte
        yamlContent, err = ioutil.ReadFile(pathToYamlFile)

        if err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>

        <span class="cov8" title="1">err = yaml.Unmarshal(yamlContent, &amp;yamlConfiguration)

        if err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>

        <span class="cov8" title="1">result := &amp;fileConfiguration{parsedYaml: yamlConfiguration}

        return result, nil</span>
}
</pre>
		
		</div>
	</body>
	<script>
	(function() {
		var files = document.getElementById('files');
		var visible;
		files.addEventListener('change', onChange, false);
		function select(part) {
			if (visible)
				visible.style.display = 'none';
			visible = document.getElementById(part);
			if (!visible)
				return;
			files.value = part;
			visible.style.display = 'block';
			location.hash = part;
		}
		function onChange() {
			select(files.value);
			window.scrollTo(0, 0);
		}
		if (location.hash != "") {
			select(location.hash.substr(1));
		}
		if (!visible) {
			select("file0");
		}
	})();
	</script>
</html>
